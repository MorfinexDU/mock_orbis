1 DESCRIÇÃO
A tabela "etapas" armazena as etapas de produção reutilizáveis que compõem as rotas de fabricação do sistema ORBIS.
Cada etapa representa uma fase específica do processo produtivo (ex.: CORTE LASER, DESTAQUE, DOBRADEIRA, MONTAGEM), contendo seus centros de produção, centros de trabalho e parâmetros necessários associados.
2 OBJETIVO

* Padronizar etapas de produção em toda a empresa
* Centralizar configuração de centros de trabalho por etapa
* Definir parâmetros necessários para cada fase do processo
* Permitir reutilização de etapas em múltiplas etapas
* Facilitar manutenção e evolução dos processos produtivos
* Integrar com sistema de cálculo de TPE do widget ORBIS

3 LÓGICA TÉCNICA DE AQUISIÇÃO DE DADOS
Fontes
* Interface administrativa do widget (criação/edição de parâmetros);
* Chamadas de API diretamente (criação/edição de parâmetros).
Script para criar tabela
CREATE TABLE etapas (
    id INT IDENTITY(1,1) PRIMARY KEY,
    nome NVARCHAR(100) NOT NULL UNIQUE,
    descricao NVARCHAR(MAX),
    centros NVARCHAR(200) NOT NULL,
    centros_trabalho NVARCHAR(MAX) NOT NULL,
    parametros_necessarios NVARCHAR(MAX) NOT NULL,
    ativa BIT DEFAULT 1,
    data_criacao DATETIME2 DEFAULT GETDATE(),
    data_modificacao DATETIME2 DEFAULT GETDATE()
);

-- Índices para performance
CREATE INDEX idx_etapas_nome ON etapas(nome);
CREATE INDEX idx_etapas_ativa ON etapas(ativa);
CREATE INDEX idx_etapas_centros ON etapas(centros);

-- Constraint para validar JSON no campo centros_trabalho
ALTER TABLE etapas
ADD CONSTRAINT chk_etapas_centros_trabalho_json 
CHECK (centros_trabalho IS NULL OR ISJSON(centros_trabalho) = 1);

-- Constraint para validar JSON no campo parametros_necessarios
ALTER TABLE etapas
ADD CONSTRAINT chk_etapas_parametros_json 
CHECK (parametros_necessarios IS NULL OR ISJSON(parametros_necessarios) = 1);




4 FILTROS
Recomendações de filtros no consumo (API/relatórios/SQL):
* Por nome
* Por descrição
* Por ativa (ativo/inativo)
* Por centro de produção
5 RECORRÊNCIA DE ATUALIZAÇÃO
* Widget/API ? atualização em tempo real (transacional).
6 CAMPO CHAVE PARA ATUALIZAÇÃO
Chave primária: `id` (INT IDENTITY)

Chave natural (UNIQUE): `nome` - garante que não existam etapas com nomes duplicados

Estratégia de operações:
CREATE (POST)
- Valida se `nome` já existe (UNIQUE constraint)
- Insere novo registro com ID auto-gerado

UPDATE (PUT)
- Identificação por `id` enviado na URL (`/orbis/etapas/:id`)
- Atualiza campos enviados no body
- Valida unicidade de `nome` se este campo for alterado

DELETE (DELETE)
- Quando usuário excluir via widget: DELETE FROM etapas WHERE id = @id
- Remove permanentemente o registro do banco
- Usado quando a etapa foi criada por engano ou não é mais necessária

DESATIVAR (PATCH)
- Quando usuário desativar via widget: UPDATE etapas SET ativa = 0 WHERE id = @id
- Mantém o registro no banco com ativa = 0
- Usado quando a etapa não deve mais aparecer, mas precisa ser mantida para histórico/auditoria
1. API – DADOS DE ENTRADA


POST /orbis/etapas – Criar nova etapa
* Descrição: Cria uma nova etapa de produção no sistema.
* Body (JSON):
{
  "nome": "CORTE LASER",
  "descricao": "Etapa de corte laser",
  "centros": "MP10",
  "centros_trabalho": ["MA303", "MA301", "DE103"],
  "parametros_necessarios": [
    "espessura_chapa",
    "material",
    "perimetro",
    "peso_peca",
    "qtd_recortes_laserchapa"
  ],
  "ativa": true
} 
* Retorno 201:
{
  "success": true,
  "data": {
    "id": 1,
    "nome": "CORTE LASER",
    "descricao": "Etapa de corte laser",
    "centros": "MP10",
    "centros_trabalho": ["MA303", "MA301", "DE103"],
    "parametros_necessarios": [
      "espessura_chapa",
      "material",
      "perimetro",
      "peso_peca",
      "qtd_recortes_laserchapa"
    ],
    "ativa": true,
    "data_criacao": "2025-10-10T14:30:00Z",
    "data_modificacao": "2025-10-10T14:30:00Z"
  }
}
* Retorno 409: {"success": false, "error": "Já existe uma etapa com este nome"}


PUT /orbis/etapas/:id - Atualizar etapa existente
* Descrição: Atualiza dados de uma etapa existente identificada pelo ID
* URL Parameter: "id" (obrigatório)
* Body (JSON):
{
  "nome": "CORTE LASER (Atualizada)",
  "descricao": "Etapa de corte laser com novos centros",
  "centros_trabalho": ["MA303", "MA301", "DE103", "MA305"]
}
* Retorno 200:
{
  "success": true,
  "data": {
    "id": 1,
    "nome": "CORTE LASER (Atualizada)",
    "descricao": "Etapa de corte laser com novos centros",
    "centros": "MP10",
    "centros_trabalho": ["MA303", "MA301", "DE103", "MA305"],
    "parametros_necessarios": [
      "espessura_chapa",
      "material",
      "perimetro",
      "peso_peca",
      "qtd_recortes_laserchapa"
    ],
    "ativa": true,
    "data_criacao": "2025-10-10T14:30:00Z",
    "data_modificacao": "2025-10-10T15:45:00Z"
  }
}
* Retorno 404: {"success": false, "error": "Etapa não encontrada"}
* Retorno 409: {"success": false, "error": "Já existe uma etapa com este nome"}

PATCH /orbis/etapas/:id/desativar - Desativar etapa
* Descrição: Soft delete - marca "ativo = 0" (mantém registro no banco)
* URL Parameter: "id" (obrigatório)
* Retorno 200:
{
  "success": true,
  "message": "Etapa desativada com sucesso",
  "data": {
    "id": 1,
    "ativa": false
  }
}

PATCH /orbis/etapas/:id/ativar - Reativar etapa
* Descrição: Marca "ativo = 1" (reativa parâmetro desativado)
* URL Parameter: "id" (obrigatório)
* Retorno 200:
{
  "success": true,
  "message": "Etapa ativada com sucesso",
  "data": {
    "id": 1,
    "ativo": true
  }
}

DELETE /orbis/etapas/:id - Excluir etapa permanentemente
* Descrição: DELETE físico - remove registro do banco definitivamente
* URL Parameter: "id" (obrigatório)
* Retorno 200:
{
  "success": true,
  "message": "Etapa excluída permanentemente"
}
* Retorno 404: “{“success": false, "error": "Etapa não encontrada”}"

7 API – DADOS DE SAÍDA

GET “/orbis/etapas” – Listar etapas
* Descrição: Retorna lista de todas as etapas (com filtros opcionais de [codigo, nome, ativo, centro_prod, descrição])
* Parâmetros: filtros opcionais
* Retorno: coleção de etapas.

GET “/orbis/etapas/:id” – Buscar etapa por ID
* Descrição: Retorna uma etapa específica pelo ID
* Retorno 200: Objeto único da etapa
* Retorno 404: “{"success": false, "error": "Etapa não encontrada"}”
GET “/orbis/etapas?ids=1,2,3” – Buscar múltiplas etapas por IDs
* Descrição: Retorna múltiplas etapas de uma vez
* Retorno 200: Coleção de etapas.
* Retorno 404: “{"success": false, "error": "Etapas não encontrada"}”

2. CATEGORIZAÇÃO DO DHIVE


3. ÁREAS IMPACTADAS PELA INFORMAÇÃO
Engenharia de Processos

4. VALOR AGREGADO PARA A COMPANHIA
* Padronização: Unifica definição de etapas produtivas em toda a empresa
* Reutilização: Mesma etapa pode ser usada em múltiplas rotas
* Manutenção: Alterar uma etapa afeta automaticamente todas as rotas
* Flexibilidade: Permite criar e modificar etapas sem alteração de código
* Rastreabilidade: Mantém histórico completo de alterações
* Integração: Base para cálculos automatizados de TPE e planejamento
* Qualidade: Garante que processos sigam etapas padronizadas e aprovadas
* Migração para 3DEXPERIENCE: Remove dependência de configurações hardcoded
5. INTEGRAÇÃO COM SISTEMA DE AUDITORIA
Todas as operações de CREATE, UPDATE, DELETE, ACTIVATE e DEACTIVATE nesta tabela DEVEM registrar logs na tabela "logs_auditoria".

1. RECEBER user_id no Body
   Todas as requisições POST, PUT, PATCH e DELETE devem receber o campo user_id:
   Body exemplo:
           {
             "nome": "...",
             "descricao": "...",
             "user_id": "eduardo.silva"  ? OBRIGATÓRIO
           }
2. CHAMAR Função de Log
   Após cada operação bem-sucedida, chamar:
           registrarLog(
             tabela: 'nome_da_tabela',
             registro_id: id_do_registro,
             operacao: 'CREATE' | 'UPDATE' | 'DELETE' | 'ACTIVATE' | 'DEACTIVATE',
             valores_anteriores: objeto_com_valores_antigos (NULL para CREATE),
             valores_novos: objeto_com_valores_novos (NULL para DELETE),
             user_id: user_id_recebido_no_body
           );
3. EXEMPLOS POR OPERAÇÃO
   CREATE (POST):
* Capturar user_id do body
* Executar INSERT na tabela
* Chamar: registrarLog('tabela', novo_id, 'CREATE', null, dados_inseridos, user_id)
   UPDATE (PUT):
*    Capturar user_id do body
*    Buscar valores anteriores: SELECT * FROM tabela WHERE id = @id
*    Executar UPDATE na tabela
*    Buscar valores novos: SELECT * FROM tabela WHERE id = @id
*    Chamar: registrarLog('tabela', id, 'UPDATE', valores_anteriores, valores_novos, user_id)
   DELETE (DELETE):
*    Capturar user_id do body
*    Buscar valores anteriores: SELECT * FROM tabela WHERE id = @id
*    Executar DELETE na tabela
*    Chamar: registrarLog('tabela', id, 'DELETE', valores_anteriores, null, user_id)
   ACTIVATE (PATCH /:id/ativar):
*    Capturar user_id do body
*    Buscar valor anterior: SELECT ativo FROM tabela WHERE id = @id
*    Executar: UPDATE tabela SET ativo = 1 WHERE id = @id
*    Chamar: registrarLog('tabela', id, 'ACTIVATE', {ativo: 0}, {ativo: 1}, user_id)
   DEACTIVATE (PATCH /:id/desativar):
*    Capturar user_id do body
*    Buscar valor anterior: SELECT ativo FROM tabela WHERE id = @id
*    Executar: UPDATE tabela SET ativo = 0 WHERE id = @id
*    Chamar: registrarLog('tabela', id, 'DEACTIVATE', {ativo: 1}, {ativo: 0}, user_id)

Elaboração de API


		

        DAPI - Document Application Programming Interface

		


